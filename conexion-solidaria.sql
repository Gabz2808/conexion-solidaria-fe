-- This script was generated by the ERD tool in pgAdmin 4.
-- Please log an issue at https://github.com/pgadmin-org/pgadmin4/issues/new/choose if you find any bugs, including reproduction steps.
BEGIN;


CREATE TABLE IF NOT EXISTS public.amigos
(
    idamigo serial NOT NULL,
    idusuario1 integer,
    idusuario2 integer,
    estado character varying(50) COLLATE pg_catalog."default",
    fechasolicitud timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT amigos_pkey PRIMARY KEY (idamigo)
);

CREATE TABLE IF NOT EXISTS public.chats
(
    idchat serial NOT NULL,
    idusuario1 integer,
    idusuario2 integer,
    fechacreacion timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT chats_pkey PRIMARY KEY (idchat)
);

CREATE TABLE IF NOT EXISTS public.comentarios
(
    idcomentario serial NOT NULL,
    idpost integer,
    idhistoria integer,
    idusuario integer,
    contenido text COLLATE pg_catalog."default",
    fechacreacion timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT comentarios_pkey PRIMARY KEY (idcomentario)
);

CREATE TABLE IF NOT EXISTS public.datosusuario
(
    iddatos serial NOT NULL,
    idusuario integer NOT NULL,
    ciudad text COLLATE pg_catalog."default",
    pais text COLLATE pg_catalog."default",
    urlimagen text COLLATE pg_catalog."default",
    CONSTRAINT datosusuario_pkey PRIMARY KEY (iddatos)
);

CREATE TABLE IF NOT EXISTS public.favoritos
(
    idfavorito serial NOT NULL,
    tipo character varying(50) COLLATE pg_catalog."default",
    idrelacion integer,
    idusuario integer,
    fechaguardado timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT favoritos_pkey PRIMARY KEY (idfavorito)
);

CREATE TABLE IF NOT EXISTS public.grupos
(
    idgrupo serial NOT NULL,
    nombre character varying(255) COLLATE pg_catalog."default" NOT NULL,
    descripcion text COLLATE pg_catalog."default",
    idcreador integer,
    fechacreacion timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT grupos_pkey PRIMARY KEY (idgrupo)
);

CREATE TABLE IF NOT EXISTS public.historias
(
    idhistoria serial NOT NULL,
    titulo character varying(255) COLLATE pg_catalog."default",
    contenido text COLLATE pg_catalog."default",
    idusuario integer,
    fechacreacion timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    estado character varying(50) COLLATE pg_catalog."default",
    CONSTRAINT historias_pkey PRIMARY KEY (idhistoria)
);

CREATE TABLE IF NOT EXISTS public.likes
(
    idlike serial NOT NULL,
    tipo character varying(50) COLLATE pg_catalog."default",
    idrelacion integer,
    idusuario integer,
    fechacreacion timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT likes_pkey PRIMARY KEY (idlike)
);

CREATE TABLE IF NOT EXISTS public.mensajesprivados
(
    idmprivado serial NOT NULL,
    idchat integer,
    idusuario integer,
    contenido text COLLATE pg_catalog."default",
    fechacreacion timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT mensajesprivados_pkey PRIMARY KEY (idmprivado)
);

CREATE TABLE IF NOT EXISTS public.miembrosgrupo
(
    idmiembro serial NOT NULL,
    idgrupo integer,
    idusuario integer,
    rol character varying(50) COLLATE pg_catalog."default" DEFAULT 'miembro'::character varying,
    fechaingreso timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT miembrosgrupo_pkey PRIMARY KEY (idmiembro)
);

CREATE TABLE IF NOT EXISTS public.notificaciones
(
    idnotificaciones serial NOT NULL,
    idusuario integer,
    tipo character varying(50) COLLATE pg_catalog."default",
    contenido text COLLATE pg_catalog."default",
    leido boolean DEFAULT false,
    fechacreacion timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT notificaciones_pkey PRIMARY KEY (idnotificaciones)
);

CREATE TABLE IF NOT EXISTS public.posts
(
    idposts serial NOT NULL,
    titulo character varying(255) COLLATE pg_catalog."default",
    contenido text COLLATE pg_catalog."default",
    idusuario integer,
    fechacreacion timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    estado character varying(50) COLLATE pg_catalog."default",
    CONSTRAINT posts_pkey PRIMARY KEY (idposts)
);


CREATE TABLE IF NOT EXISTS public.compartidos
(
    idcompartido serial NOT NULL,
    idusuario integer,
    idpost integer,
    fechacreacion timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT compartidos_pkey PRIMARY KEY (idcompartido),
    CONSTRAINT compartidos_idusuario_fkey FOREIGN KEY (idusuario) REFERENCES public.usuario (idusuario) ON DELETE CASCADE,
    CONSTRAINT compartidos_idpost_fkey FOREIGN KEY (idpost) REFERENCES public.posts (idposts) ON DELETE CASCADE
);


CREATE TABLE IF NOT EXISTS public.producto
(
    idproducto serial NOT NULL,
    nombre character varying(255) COLLATE pg_catalog."default",
    descripcion text COLLATE pg_catalog."default",
    precio numeric(10, 2),
    stock integer,
    idusuario integer,
    fechacreacion timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    "idCategoria" integer NOT NULL DEFAULT 1,
    imagen text COLLATE pg_catalog."default" NOT NULL,
    CONSTRAINT producto_pkey PRIMARY KEY (idproducto)
);

CREATE TABLE IF NOT EXISTS public.productoguardado
(
    idpguardado serial NOT NULL,
    idusuario integer,
    productoid integer,
    fechaguardado timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT productoguardado_pkey PRIMARY KEY (idpguardado)
);

CREATE TABLE IF NOT EXISTS public.usuario
(
    idusuario serial NOT NULL,
    nombre character varying(100) COLLATE pg_catalog."default",
    apellido character varying(100) COLLATE pg_catalog."default",
    email character varying(255) COLLATE pg_catalog."default",
    password text COLLATE pg_catalog."default" NOT NULL,
    fecharegistro timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    rol character varying(50) COLLATE pg_catalog."default",
    estado character varying(50) COLLATE pg_catalog."default",
    CONSTRAINT usuario_pkey PRIMARY KEY (idusuario),
    CONSTRAINT usuario_email_key UNIQUE (email)
);

-- Tabla perfil de usuario
CREATE TABLE IF NOT EXISTS usuarios_perfil (
    idUsuario INTEGER PRIMARY KEY,
    direccion TEXT,
    telefono TEXT,
    foto_perfil TEXT,
    biografia TEXT,
    FOREIGN KEY (idUsuario) REFERENCES usuario(idusuario)
);
--Triggers para actualizar contadores en la tabla posts

CREATE OR REPLACE FUNCTION actualizar_likes() RETURNS TRIGGER AS $$
BEGIN
    IF TG_OP = 'INSERT' THEN
        UPDATE public.posts SET total_likes = total_likes + 1 WHERE idposts = NEW.idpost;
    ELSIF TG_OP = 'DELETE' THEN
        UPDATE public.posts SET total_likes = total_likes - 1 WHERE idposts = OLD.idpost;
    END IF;
    RETURN NULL;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_likes
AFTER INSERT OR DELETE ON public.likes
FOR EACH ROW EXECUTE FUNCTION actualizar_likes();


CREATE OR REPLACE FUNCTION actualizar_comentarios() RETURNS TRIGGER AS $$
BEGIN
    IF TG_OP = 'INSERT' THEN
        UPDATE public.posts SET total_comentarios = total_comentarios + 1 WHERE idposts = NEW.idpost;
    ELSIF TG_OP = 'DELETE' THEN
        UPDATE public.posts SET total_comentarios = total_comentarios - 1 WHERE idposts = OLD.idpost;
    END IF;
    RETURN NULL;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_comentarios
AFTER INSERT OR DELETE ON public.comentarios
FOR EACH ROW EXECUTE FUNCTION actualizar_comentarios();


CREATE OR REPLACE FUNCTION actualizar_compartidos() RETURNS TRIGGER AS $$
BEGIN
    IF TG_OP = 'INSERT' THEN
        UPDATE public.posts SET total_compartidos = total_compartidos + 1 WHERE idposts = NEW.idpost;
    ELSIF TG_OP = 'DELETE' THEN
        UPDATE public.posts SET total_compartidos = total_compartidos - 1 WHERE idposts = OLD.idpost;
    END IF;
    RETURN NULL;
    END;    
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_compartidos
AFTER INSERT OR DELETE ON public.compartidos
FOR EACH ROW EXECUTE FUNCTION actualizar_compartidos();

-- Vista dinamica para buscar productos

CREATE OR REPLACE FUNCTION buscar_productos(
    nombre_busqueda TEXT DEFAULT NULL,
    precio_minimo NUMERIC DEFAULT NULL,
    precio_maximo NUMERIC DEFAULT NULL
) RETURNS TABLE (
    idproducto INTEGER,
    nombre TEXT,
    descripcion TEXT,
    precio NUMERIC,
    stock INTEGER,
    idusuario INTEGER,
    fechacreacion TIMESTAMP,
    idCategoria INTEGER,
    imagen TEXT
) AS $$
BEGIN
    RETURN QUERY 
    SELECT 
        p.idproducto, p.nombre, p.descripcion, p.precio, 
        p.stock, p.idusuario, p.fechacreacion, 
        p."idCategoria", p.imagen
    FROM public.producto p
    WHERE 
        (nombre_busqueda IS NULL OR p.nombre ILIKE '%' || nombre_busqueda || '%') AND
        (precio_minimo IS NULL OR p.precio >= precio_minimo) AND
        (precio_maximo IS NULL OR p.precio <= precio_maximo);
END;
$$ LANGUAGE plpgsql;

-- Left Join
SELECT 
    g.idGrupo,
    g.nombre AS nombre_grupo,
    mg.idUsuario
FROM 
    grupos g
LEFT JOIN miembrosgrupo mg ON g.idgrupo = mg.idgrupo;



ALTER TABLE IF EXISTS public.amigos
    ADD CONSTRAINT amigos_idusuario1_fkey FOREIGN KEY (idusuario1)
    REFERENCES public.usuario (idusuario) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;


ALTER TABLE IF EXISTS public.amigos
    ADD CONSTRAINT amigos_idusuario2_fkey FOREIGN KEY (idusuario2)
    REFERENCES public.usuario (idusuario) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;


ALTER TABLE IF EXISTS public.chats
    ADD CONSTRAINT chats_idusuario1_fkey FOREIGN KEY (idusuario1)
    REFERENCES public.usuario (idusuario) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;


ALTER TABLE IF EXISTS public.chats
    ADD CONSTRAINT chats_idusuario2_fkey FOREIGN KEY (idusuario2)
    REFERENCES public.usuario (idusuario) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;


ALTER TABLE IF EXISTS public.comentarios
    ADD CONSTRAINT comentarios_idhistoria_fkey FOREIGN KEY (idhistoria)
    REFERENCES public.historias (idhistoria) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;


ALTER TABLE IF EXISTS public.comentarios
    ADD CONSTRAINT comentarios_idpost_fkey FOREIGN KEY (idpost)
    REFERENCES public.posts (idposts) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;


ALTER TABLE IF EXISTS public.comentarios
    ADD CONSTRAINT comentarios_idusuario_fkey FOREIGN KEY (idusuario)
    REFERENCES public.usuario (idusuario) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;


ALTER TABLE IF EXISTS public.datosusuario
    ADD CONSTRAINT datosusuario_idusuario_fkey FOREIGN KEY (idusuario)
    REFERENCES public.usuario (idusuario) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;


ALTER TABLE IF EXISTS public.favoritos
    ADD CONSTRAINT favoritos_idusuario_fkey FOREIGN KEY (idusuario)
    REFERENCES public.usuario (idusuario) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;


ALTER TABLE IF EXISTS public.grupos
    ADD CONSTRAINT grupos_idcreador_fkey FOREIGN KEY (idcreador)
    REFERENCES public.usuario (idusuario) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;


ALTER TABLE IF EXISTS public.historias
    ADD CONSTRAINT historias_idusuario_fkey FOREIGN KEY (idusuario)
    REFERENCES public.usuario (idusuario) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;


ALTER TABLE IF EXISTS public.likes
    ADD CONSTRAINT likes_idusuario_fkey FOREIGN KEY (idusuario)
    REFERENCES public.usuario (idusuario) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;


ALTER TABLE IF EXISTS public.mensajesprivados
    ADD CONSTRAINT mensajesprivados_idchat_fkey FOREIGN KEY (idchat)
    REFERENCES public.chats (idchat) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;


ALTER TABLE IF EXISTS public.mensajesprivados
    ADD CONSTRAINT mensajesprivados_idusuario_fkey FOREIGN KEY (idusuario)
    REFERENCES public.usuario (idusuario) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;

--Contadores
ALTER TABLE public.posts
    ADD COLUMN total_likes integer DEFAULT 0;

ALTER TABLE public.posts
    ADD COLUMN total_comentarios integer DEFAULT 0;

ALTER TABLE public.posts
    ADD COLUMN total_compartidos integer DEFAULT 0;

END;
